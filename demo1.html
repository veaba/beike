<!doctype html>
<html lang="en">
<head>
		<meta charset="UTF-8">
		<meta name="viewport"
		      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">
		<title>Document</title>
		<style>
				#canvas{
						border: 1px solid red;
				}
		</style>
		<script>
			var sun = new Image();
			var earth = new Image();
			
			function init() {
				sun.src = 'https://mdn.mozillademos.org/files/1456/Canvas_sun.png';
				earth.src = 'https://mdn.mozillademos.org/files/1429/Canvas_earth.png';
				window.requestAnimationFrame(draw);
			}
			
			function draw() {
				var ctx = document.getElementById('canvas').getContext('2d');
				
				// ctx.globalCompositeOperation = 'destination-over'; // 属性设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上。
				ctx.clearRect(0, 0, 500, 500); // clear canvas
				
				ctx.fillStyle = 'rgba(0,0,0,0.4)';
				ctx.strokeStyle = 'rgba(0,153,255,0.4)';
				ctx.save();
				ctx.translate(250, 250); //translate() 方法重新映射画布上的 (0,0) 位置。
				
		
				var time = new Date();
				ctx.rotate(((2 * Math.PI) / 60) * time.getSeconds() + ((2 * Math.PI) / 60000) * time.getMilliseconds());//rotate() 方法旋转画布的坐标系统。
				ctx.translate(105, 0);
				ctx.fillRect(0, -12, 50, 24); // Shadow
				ctx.drawImage(earth, -12, -12);
				
				
				window.requestAnimationFrame(draw);
				
				ctx.restore(); //restore() 方法将绘图状态置为保存值。restore() 方法从栈中弹出存储的图形状态并恢复 CanvasRenderingContext2D 对象的属性、剪切路径和变换矩阵的值。
				
				// Earth
				ctx.beginPath();
				ctx.arc(250, 250, 105, 0, Math.PI * 2, false); // Earth orbit
				ctx.stroke();
			}
			
			init();
		</script>
</head>
<body>
<canvas id="canvas" width="500" height="500"></canvas>
</body>
</html>